import { Head, Image } from 'mdx-deck';
import { FullScreenCode, Invert } from 'mdx-deck/layouts';

<Head>
	<title>React Performance</title>
	<meta name='viewport' content='width=device-width, initial-scale=1.0' />
	<meta name='keywords' content='React, Performance' />
	<meta
		name='description'
		content='Slides for presentation on react performance.'
	/>
	<meta name='author' content='Sibasish Mohanty' />
</Head>

# React Performance

Tips, tricks to improve the performance of your react app

### Sibasish Mohanty

---

## What this talk is

- Something
- Nothing
- The last point

---

## What this talk is _not_

- Some other thing
- And this thing

---

> Performance optimizations are not free. They ALWAYS come with a cost but do
> NOT always come with a benefit to offset that cost.

> [Kent C Dodds](https://kentcdodds.com/)

---

## The production build

- By default, React includes many useful warnings for development. However, they
  make React larger and slower.

- Use the
  [production version](https://reactjs.org/docs/optimizing-performance.html#use-the-production-build)
  when you deploy the app.

---

## Code splitting

- Loading less code will speed up your app
- Dynamic imports in React with `<React.Suspense />` and `React.lazy()`
- Eager loading for better UX
- Prefetch dynamic imports using
  [webpack magic comments](https://webpack.js.org/api/module-methods/#magic-comments)
- Determine the need of code splitting with the
  [coverage feature of the developer tools](https://developers.google.com/web/tools/chrome-devtools/coverage)

---

import { LazyLoad } from './components/lazy-load';

<LazyLoad />

---

## Memoize expensive calculations

- Bulky functions executed every single render leads to a performance bottleneck
- Use `useMemo` hook to run a function when the results actually needs to be
  re-evaluated
- Don't overuse `useMemo` and `useCallback`

---

### Which one is better for performance?

import { Highlighter } from './components/highlighter';

<Highlighter>{`const removeUser = user => {
  setUser(allUsers => allUsers.filter(u => u !== user))
}
`}</Highlighter>

... And the one with `useCallback`

<Highlighter>{`const removeUser = React.useCallback(user => {
  setUser(allUsers => allUsers.filter(u => u !== user))
}, [])
`}</Highlighter>

---

### Every line of code which is executed comes with a cost

<Highlighter>
	{`const removeUser = user => {
  setUser(allUsers => allUsers.filter(u => u !== user))
}
const removeUserCallback = React.useCallback(removeUser, []);
`}
</Highlighter>

... And here is the original one

<Highlighter>{`const removeUser = user => {
  setUser(allUsers => allUsers.filter(u => u !== user))
}
`}</Highlighter>

---

## Avoid unndecessary re-renders

- Optimze slow renders before fixing re-renders
- Immutability and reference equality

---

## Viewport based rendering

---

## Bundling and minification
